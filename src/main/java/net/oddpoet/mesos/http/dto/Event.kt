package net.oddpoet.mesos.http.dto

import kotlin.reflect.jvm.internal.impl.protobuf.ByteString

/**
 * Scheduler event API.
 *
 * An event is described using the standard protocol buffer "union"
 * trick, see:
 * https://developers.google.com/protocol-buffers/docs/techniques#union.
 *
 * ref: https://github.com/apache/mesos/blob/master/include/mesos/v1/scheduler/scheduler.proto#L34
 */
data class Event(
        val type: Type? = Type.UNKNOWN,
        val subscribed: Subscribed? = null,
        val offers: Offers? = null,
        val inverseOffers: InverseOffers? = null,
        val rescind: Rescind? = null,
        val rescindInverseOffer: RescindInverseOffer? = null,
        val update: Update? = null,
        val updateOperationStatus: UpdateOperationStatus? = null,
        val message: Message? = null,
        val failure: Failure? = null,
        val error: Error? = null) {

    /**
     * Possible event types, followed by message definitions if applicable.
     */
    enum class Type {
        /**
         * This must be the first enum value in ths list,
         * to ensure that if 'type' is not set, the default value is UNKNOWN.
         * This enables enum values to be added in a backwards-compatible way. See: MESOS-4997
         */
        UNKNOWN,
        SUBSCRIBED,
        OFFERS,
        INVERSE_OFFERS,
        RESCIND,
        RESCIND_INVERSE_OFFER,
        UPDATE,
        UPDATE_OPERATION_STATUS,
        MESSAGE,
        FAILURE,
        ERROR,

        /**
         * Periodic message sent by the Mesos master according to
         * 'Subscribed.heartbeat_interval_seconds'. If the scheduler does
         * not receive any events (including heartbeats) for an extended
         * period of time (e.g., 5 x heartbeat_interval_seconds), there is
         * likely a network partition. In such a case the scheduler should
         * close the existing subscription connection and resubscribe
         * using a backoff strategy.
         */
        HEARTBEAT
    }


    /**
     * First event received when the scheduler subscribes.
     */
    data class Subscribed(
            val frameworkId: FrameworkID,
            /**
             * This value will be set if the master is sending heartbeats. See the comment above on 'HEARTBEAT'
             * for more details.
             */
            val heartbeatIntervalSeconds: Double?,
            /**
             * Since Mesos 1.1.
             */
            val masterInfo: MasterInfo?)

    /**
     * Received whenever there are new resources that are offered to the
     * scheduler. Each offer corresponds to a set of resources on an
     * agent. Until the scheduler accepts or declines an offer the
     * resources are considered allocated to the scheduler.
     */
    data class Offers(val offers: List<Offer>)

    /**
     * Received whenever there are resources requested back from the
     * scheduler. Each inverse offer specifies the agent, and
     * optionally specific resources. Accepting or Declining an inverse
     * offer informs the allocator of the scheduler's ability to release
     * the specified resources without violating an SLA. If no resources
     * are specified then all resources on the agent are requested to be
     * released.
     */
    data class InverseOffers(val inverseOffers: List<InverseOffer>?)

    /**
     * Received when a particular offer is no longer valid (e.g., the
     * agent corresponding to the offer has been removed) and hence
     * needs to be rescinded. Any future calls ('Accept' / 'Decline') made
     * by the scheduler regarding this offer will be invalid.
     */
    data class Rescind(val offerId: OfferID)

    /**
     * Received when a particular inverse offer is no longer valid
     * (e.g., the agent corresponding to the offer has been removed)
     * and hence needs to be rescinded. Any future calls ('Accept' /
     * 'Decline') made by the scheduler regarding this inverse offer
     * will be invalid.
     */
    data class RescindInverseOffer(val inverseOfferId: OfferID)

    /**
     * Received whenever there is a status update that is generated by
     * the executor or agent or master. Status updates should be used by
     * executors to reliably communicate the status of the tasks that
     * they manage. It is crucial that a terminal update (see TaskState
     * in v1/mesos.proto) is sent by the executor as soon as the task
     * terminates, in order for Mesos to release the resources allocated
     * to the task. It is also the responsibility of the scheduler to
     * explicitly acknowledge the receipt of a status update. See
     * 'Acknowledge' in the 'Call' section below for the semantics.
     *
     * A task status update may be used for guaranteed delivery of some
     * task-related information, e.g., task's health update. Such
     * information may be shadowed by subsequent task status updates, that
     * do not preserve fields of the previously sent message.
     */
    data class Update(val status: TaskStatus)

    /**
     * Received when there is an operation status update generated by the
     * master, agent, or resource provider. These updates are only sent to
     * the framework for operations which had the operation ID set by the
     * framework. It is the responsibility of the scheduler to explicitly
     * acknowledge the receipt of a status update.
     * See 'AcknowledgeOperationStatus' in the 'Call' section below for
     * the semantics.
     */
    data class UpdateOperationStatus(val status: OperationStatus)


    /**
     * Received when a custom message generated by the executor is
     * forwarded by the master. Note that this message is not
     * interpreted by Mesos and is only forwarded (without reliability
     * guarantees) to the scheduler. It is up to the executor to retry
     * if the message is dropped for any reason.
     */
    data class Message(
            val agentId: AgentID,
            val executorId: ExecutorID,
            val data: ByteString)

    /**
     * Received when an agent is removed from the cluster (e.g., failed
     * health checks) or when an executor is terminated. Note that, this
     * event coincides with receipt of terminal UPDATE events for any
     * active tasks belonging to the agent or executor and receipt of
     * 'Rescind' events for any outstanding offers belonging to the
     * agent. Note that there is no guaranteed order between the
     * 'Failure', 'Update' and 'Rescind' events when an agent or executor
     * is removed.
     * TODO(vinod): Consider splitting the lost agent and terminated
     * executor into separate events and ensure it's reliably generated.
     */
    data class Failure(
            val agentId: AgentID?,
            /**
             * If this was just a failure of an executor on an agent then
             * 'executor_id' will be set and possibly 'status' (if we were
             * able to determine the exit status).
             */
            val executorId: ExecutorID?,
            /**
             * On Posix, `status` corresponds to termination information in the
             * `stat_loc` area returned from a `waitpid` call. On Windows, `status`
             * is obtained via calling the `GetExitCodeProcess()` function. For
             * messages coming from Posix agents, schedulers need to apply
             * `WEXITSTATUS` family macros or equivalent transformations to obtain
             * exit codes.

             * TODO(alexr): Consider unifying Windows and Posix behavior by returning
             * exit code here, see MESOS-7241.
             */
            val status: Int?)

    /**
     * Received when there is an unrecoverable error in the scheduler (e.g.,
     * scheduler failed over, rate limiting, authorization errors etc.). The
     * scheduler should abort on receiving this event.
     */
    data class Error(val message: String)
}

